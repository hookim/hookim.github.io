---
layout: post
title: 0/1 knapsack 
date: 2024-02-18 15:18:09
description: 0/1 knapsack을 푸는 여러 방식
tags: 
categories: 알고리즘
---
## 개요

가방에 물건을 최대한 담으면서 가방에 담긴 물건의 가치를 최대치로 만드는것에 관련된 문제. 물건에는 무게와 가치가 있다. 그리고 가방에는 담을 수 있는 무게의 한계가 있다. 이들을 모두 고려하면서 물건을 선택하는것에 관한 문제이다. 0/1은 물건을 선택하거나 아니거나이기 때문이다. 물건의 부분만을 취할 수 없는 케이스다. 

## Brute Force

완전탐색의 방식을 생각해보자면 우선 모든 부분집합을 살펴봐서 가장 최대값을 찾는 방법일 수 있겠다.  

```cpp
// 가능한 최대 가치를 리턴
int knapsack(현재까지의 총무게, 선택할 아이템 인덱스){

// 만약 현재 선택한 아이템을 포함했을 때 총무게보다 크다면 그 아이템은 선택에서 배재한다.
	return knapsack(현재까지의 총무게, 다음순서의 인덱스)
 
// 그게 아니라면 아이템을 선택한 경우와 그렇지 않은 경우중 최대값을 리턴한다. 
	return 현재 아이템 가치 + knapsack(현재까지의 총무게 + 현재아이템 무게, 다음순서의 인덱스)
	와 kanpsack(현재까지의 총무게, 다음 순서의 인덱스) 중에서 더 큰 값 

}
```

## DP -Top Down Memoization

재귀를 돌 때 같은 패러미터를 갖는 재귀가 여러번 호출되는 점을 이용한다. 같은 패러미터인 경우에 오버헤드가 상대적으로 큰 함수호출 대신에 미리 저장된 정보를 전달할 수 있다. 

```cpp
// 기존의 BruteForce와 일정
// 최초 총무게, 아이템인덱스 크기 만큼의 dp 2차원 배열을 만든다. 

// 만약 dp에 이미 값이 들어있다면 그값을 리턴한다.
	return dp[현재까지의 총무게][다음순서의 인덱스]

// 만약 현재 선택한 아이템이 총무게보다 크다면 그 아이템은 선택에서 배재한다.
	return dp[현재까지의 총무게][다음순서의 인덱스] = knapsack(현재까지의 총무게, 다음순서의 인덱스)

// 그게 아니라면 아이템을 선택한 경우와 그렇지 않은 경우중 최대값을 리턴한다. 
	return dp[현재까지의 총무게][다음순서의 인덱스] = 현재 아이템 가치 + knapsack(현재까지의 총무게 + 현재아이템 무게, 다음순서의 인덱스)
	와 kanpsack(현재까지의 총무게, 다음 순서의 인덱스) 중에서 더 큰 값 

}

```

## DP - Bottom Up

여기서는 고려하는 인덱스 번호범위, 가방의 가용무게 범위 두 요소를 바탕으로 테이블을 만든다. dp[i][W]는 가방의 가용범위 W이고 아이템을 i번째 까지만 고려했을 때의 최대 이익은 어떻게 되는가를 저장한다. 테이블을 만들때 초반 초기화 부분이 있고 이제 이로부터 시작해서 테이블을 생성해 나가는 파트가 있다. 

```cpp
// N는 아이템의 개수(최대번호), W는 가방 무게 한계. 0일때도 고려한다.
dp[0 ~ 아이템의 최대 개수][0 ~ 가방 무게한계]

// *** ~~초기화 작업~~ ***
// 아이템을 아무것도 고려하지 않는다면 가치는 전부 0이된다. 
dp[0][0 ~ 가방무게한계] = 0

//아이템을 1개까지만 고려한다면 가방 용적이 해당 아이템 무게보다 커질때부터 담는다.
if(현재테이블 가방무게한계 >= 1번아이템 무게) 
	dp[1][0 ~ 가방무게한계] = 1번 아이템 가치
// *** ~~초기화 작업 종료~~ ***

// *** ~~테이블 생성~~ ***
// 우선 현재 아이템 무게가 현재 용적보다 크다면 이전 dp 결과를 가져온다.
if(현재테이블 가방무게한계 < 현재 아이템 무게) 
	dp[현재아이템][0 ~ 가방무게한계] = dp[현재아이템-1][0 ~ 가방무게 한계]
// 그게 아니라면 비교한다. 이 아이템을 선택하지 않는경우 와 이 현재 용량에서 현재 아이템의 무게를 뺀 용량이었을 때의 최대 가치 + 현재아이템의 무게를 비교해서 더 큰값을 집어넣는다. 
dp[현재아이템][현재 가방무게한계] 
= max(dp[현재아이템-1][현재 가방무게한계], dp[현재아이템][현재 가방무게한계 - 현재 아이템 무게] + 현재 아이템의 가치)

dp[N][W] //정답
```

여기서 조금 생소한 포인트는 가방 무게 한계에서 현재 아이템무게를 뺐을때의 경우를 참조하는 거다. 현재 아이템을 집어넣기 위해서 빈 공간을 찾아내는 느낌으로 이해하면 된다.

## 참고
[0/1 Knapsack Problem - GeeksforGeeks](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/)

[Knapsack: Top-down, Memoization & Bottom-up](https://loctv.wordpress.com/2019/12/14/knapsack-top-down-memoization-bottom-up/)
